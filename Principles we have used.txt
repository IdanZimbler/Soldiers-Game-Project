במהלך המטלה השתמשנו הרבה בעקרונות תכנות מונחה עצמים, השתמשנו הרבה בירושה והכלה.
בכל מהלך המטלה השתמשנו בעקרנות של SOLID.
Single responsibility principle - כל מחלקה אחראית על תחום מסוים במשחק, לדוגמא רק מחלקת Game יכולה "לשחק" את המשחק
Open/closed principle - כתבנו את הקוד בצורה גנרית ככל הניתן, לדוגמא השתמשנו בstrategy desing pattern עבור אסטרטגיות שונות של שחקן מחשב,
כמו כן השתמשנו בInterface שמייצג קלט למשחק (גם לצעדים וגם לקונפיגורציה) כך שבעתיד במידה ונרצה לשנות את שיטת הקלט זה יהיה פשוט רק על ידי מימוש הממשק המתאים,
בנוסף השתמשנו גם בfactory design pattern כך שברגע שנרצה להוסיף סוג חדש של חייל/עצם/נשק/מגן הדבר יעשה בצורה פשוטה ונוחה ע'י שינוי קטן בfactory המתאים.
Liskov substitution principle - כאשר עשינו פונקציה מסויימת שמקבלת בארגומנטים את הbase class דאגנו שהפונקציה תדע להשתמש גם בארגומנטים שיורשים מאותו base class,
דוגמא לכך ניתן לראות במחלקה Game בפונקציה InitializeGame שמקבלת את מחלקת אב, ואין בעיה אם נשלח אליה כל אוביקט שיורש מאותו מחלקת אב.
Interface segregation principle - בפרויקט כולו העדפנו לכתוב הרבה ממשקים ומחלקות אבסטרקטיות במקום מחלקה אחת גדולה,
דגומא לכך ניתן לראות במחלקה soldier שמממשת בצורה היררכית הרבה ממשקים ומחלקות אבסטרקטיות.
Dependency inversion principle - דוגמא לכך ניתן לראות במחלקת Game שיודעת לאתחל את המשחק ע'י "קבלת" מחלקות אבסטרקטיות ולא משהו ספציפי. 

יצרנו היררכיה של ירושות, כאשר קיימת מחלקה שמייצגת אובייקט שניתן לשים על לוח המשחק (AOnBoard) וממנו יורשים כל האובייקטים שנמצאים על הלוח,
לדוגמא חיילים, נשקים, מגנים וכו'.
והשתמשנו בdesign patterns הבאים:
Singleton - עבור מחלקת הGame
Factory - עבור נשק,עצם,מגן וחיילים
Strategy - עבור אסטרטגיות שונות של שחקנים המחשב
Prototype design pattern - על מנת שנוכל לבצע העתקה עמוקה לכל אובייקט מסוג AOnBoard בתוך הGameBoard
